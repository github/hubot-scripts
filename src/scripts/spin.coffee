# Spin & spun text formatter script
#
# Script can be used to generate different combinations of the input text by variating synonyms for example.
#
# 1. supports nested sets
# 2. supports multiline input
#
# spin me <query> - Returns a spun version of the input.
# spun me <query> - Returns a spintax version of the input using API.
# spun and spin me <query> - Returns a spun version of the input using spintax API first.
# spin the last spun - Returns a spun version of the input generated by the last spun me call.
#
# Example: spin me This is {my nested {spintax|spuntext} formatted string|your nested {spintax|spuntext} formatted string} test.
# 
# TODO: 1. support different syntaxes like '[spin]', '~', '[/spin]' instead of default '{', '|', '}'
#       2. reserved words not to spin
#
crypto = require 'crypto'
env = process.env

# spin vars
split_str = '|'
replace_regexp_str = /[{}]/gi
match_regexp_str = /{[^{}]+?}/gi

spin = (txt) ->
	if txt
		txt = capture(txt) while txt.match(match_regexp_str)
	txt

capture = (txt) ->
	match = txt.match(match_regexp_str)
	if (match[0])
		words = match[0].split(split_str)
		replace = words[Math.floor(Math.random()*words.length)].replace(replace_regexp_str, '')
		txt = txt.replace(match[0], replace)
	txt

# spun vars
secret_key = env.HUBOT_SPINNER_SECRET_KEY
access_key = env.HUBOT_SPINNER_ACCESS_KEY
host = 'www.articlemanager.us'
path = '/api/spinner.php'
version = '2011-06-24'
scheme = 'http'

gmdatenow = () ->
	g = new Date()
	m = g.getMonth() + 1
	d = g.getDate()
	y = g.getFullYear()
	h = g.getHours()+2
	i = g.getMinutes()
	s = g.getSeconds()
	"#{y}-#{m}-#{d} #{h}:#{i}:#{s}"

get_signature = (host, path, secret_key, access_key, timestamp, version) ->
	newline = "\n"
	request = "timestamp=#{escape(timestamp)}&version=#{escape(version)}&access_key=#{escape(access_key)}"
	data = "GET" + newline + host + newline + path + newline + request
	hmac = crypto.createHmac('sha256', secret_key)
	hmac.update(data)
	hmac.digest('base64')

spun = (msg, spinner = null, robot_brain = null) ->
	timestamp = gmdatenow()
	signature = get_signature(host, path, secret_key, access_key, timestamp, version)
	msg.http(scheme + "://" + host + path)
		.query
			timestamp: timestamp
			version: version
			access_key: access_key
			signature: signature
			type: 'json'
		.post(msg.match[1]) (err, res, body) ->
			if err
				msg.send err
			else if res.statusCode is not 200
				msg.send "Service not available! Status code: " + res.statusCode
			else
				body = JSON.parse(body)
				if body.response is 'error'
					msg.send body.message
				else
					if spinner
						msg.send spinner body.message
					else
						# set to the memory so user can spin it with separate "spin the last spun" command
						if robot_brain
							if not robot_brain.data.spin
								robot_brain.data.spin = []
							robot_brain.data.spin[msg.message.user.reply_to] = body.message
						msg.send body.message

module.exports = (robot) ->
	robot.hear /^spin me ([\s\S]*)/i, (msg) ->
		msg.send spin msg.match[1]

	robot.hear /^spun me ([\s\S]*)/i, (msg) ->
		spun(msg, null, robot.brain)

	robot.hear /^spun and spin me ([\s\S]*)/i, (msg) ->
		spun(msg, spin)

	robot.hear /^spin the last spun$/i, (msg) ->
		# get input from memory
		if @robot.brain.data.spin[msg.message.user.reply_to]
			msg.send spin robot.brain.data.spin[msg.message.user.reply_to]
		else
			msg.send "Nothing so spin. Please use spun first."